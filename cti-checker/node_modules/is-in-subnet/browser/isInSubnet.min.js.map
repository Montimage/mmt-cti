{"version":3,"file":"isInSubnet.min.js","sources":["../node_modules/tslib/tslib.es6.js","../src/util.ts","../src/ipRange.ts","../src/ipv4.ts","../src/ipv6.ts","../src/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","// RegExp for testing if a string represents an IPv4 address\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`;\nconst IPv4Reg = new RegExp(`^${v4Str}$`);\n\n// RegExp for testing if a string represents an IPv6 address\nconst v6Seg = '(?:[0-9a-fA-F]{1,4})';\nconst IPv6Reg = new RegExp(\n  '^(' +\n    `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n    `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n    `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` +\n    `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` +\n    `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` +\n    `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` +\n    `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` +\n    `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` +\n    ')(%[0-9a-zA-Z]{1,})?$'\n);\n\n/**\n * Returns true if the string represents an IPv4 address. Matches Node.js net.isIPv4\n * functionality.\n */\nexport function isIPv4(s: string) {\n  return IPv4Reg.test(s);\n}\n\n/**\n * Returns true if the string represents an IPv6 address. Matches Node.js net.isIPv6\n * functionality.\n */\nexport function isIPv6(s: string) {\n  return IPv6Reg.test(s);\n}\n\nexport function isIP(s: string) {\n  if (isIPv4(s)) return 4;\n  if (isIPv6(s)) return 6;\n  return 0;\n}\n","export default {\n  /** localhost IP ranges */\n  localhost: {\n    /** the localhost address ranges for IPv4 */\n    ipv4: ['127.0.0.0/8'],\n\n    /** the localhost address ranges for IPv6 */\n    ipv6: ['::1/128']\n  },\n\n  /** private IP ranges */\n  private: {\n    /** private address ranges for IPv4 */\n    ipv4: [\n      '10.0.0.0/8', // RFC 1918\n      '172.16.0.0/12', // RFC 1918\n      '192.168.0.0/16' // RFC 1918\n    ],\n\n    /** private address ranges for IPv6 */\n    ipv6: [\n      'fe80::/10', // link-local address\n      'fc00::/7' // unique local address (ULA)\n    ]\n  },\n\n  /** reserved IP ranges */\n  reserved: {\n    /** reserved address ranges for IPv4 */\n    ipv4: [\n      '0.0.0.0/8', // broadcast \"this\"\n      '100.64.0.0/10', // carrier-grade NAT\n      '169.254.0.0/16', // DHCP fallback\n      '192.0.0.0/24', // IANA Special Purpose Address Registry\n      '192.0.2.0/24', // TEST-NET-1 for documentation examples\n      '192.88.99.0/24', // deprecated 6to4 anycast relays\n      '198.18.0.0/15', // for testing inter-network comms between two subnets\n      '198.51.100.0/24', // TEST-NET-2 for documentation examples\n      '203.0.113.0/24', // TEST-NET-3 for documentation examples\n      '224.0.0.0/4', // multicast\n      '240.0.0.0/4', // reserved unspecified\n      '255.255.255.255/32' // limited broadcast address\n    ],\n\n    /** reserved address ranges for IPv6 */\n    ipv6: [\n      '::/128', // unspecified address\n      '64:ff9b::/96', // IPv4/IPv6 translation\n      '100::/64', // discard prefix\n      '2001::/32', // Teredo tunneling\n      '2001:10::/28', // deprecated\n      '2001:20::/28', // ORCHIDv2\n      '2001:db8::/32', // for documentation and examples\n      '2002::/16', // 6to4\n      'ff00::/8' // multicast\n    ]\n  }\n};\n","import * as util from './util';\nimport ipRange from './ipRange';\n\n/**\n * Given an IPv4 address, convert it to a 32-bit long integer.\n * @param ip the IPv4 address to expand\n * @throws if the string is not a valid IPv4 address\n */\nfunction ipv4ToLong(ip: string) {\n  if (!util.isIPv4(ip)) {\n    throw new Error(`not a valid IPv4 address: ${ip}`);\n  }\n  const octets = ip.split('.');\n  return (\n    ((parseInt(octets[0], 10) << 24) +\n      (parseInt(octets[1], 10) << 16) +\n      (parseInt(octets[2], 10) << 8) +\n      parseInt(octets[3], 10)) >>>\n    0\n  );\n}\n\n/**\n * Test if the given IPv4 address is contained in the specified subnet.\n * @param address the IPv4 address to check\n * @param subnet the IPv4 CIDR to test (or an array of them)\n * @throws if the address or subnet are not valid IP addresses, or the CIDR prefix length\n *  is not valid\n */\nexport function isInSubnet(address: string, subnetOrSubnets: string | string[]): boolean {\n  return createChecker(subnetOrSubnets)(address);\n}\n\n/**\n * The functional version, creates a checking function that takes an IPv4 Address and\n * returns whether or not it is contained in (one of) the subnet(s).\n * @param subnet the IPv4 CIDR to test (or an array of them)\n * @throws if the subnet is not a valid IP addresses, or the CIDR prefix length\n *  is not valid\n */\nexport function createChecker(\n  subnetOrSubnets: string | string[]\n): (address: string) => boolean {\n  if (Array.isArray(subnetOrSubnets)) {\n    const checks = subnetOrSubnets.map(subnet => createLongChecker(subnet));\n    return address => {\n      const addressLong = ipv4ToLong(address);\n      return checks.some(check => check(addressLong));\n    };\n  }\n  const check = createLongChecker(subnetOrSubnets);\n  return address => {\n    const addressLong = ipv4ToLong(address);\n    return check(addressLong);\n  };\n}\n\n// this is the most optimised checker.\nfunction createLongChecker(subnet: string): (addressLong: number) => boolean {\n  const [subnetAddress, prefixLengthString] = subnet.split('/');\n  const prefixLength = parseInt(prefixLengthString, 10);\n  if (!subnetAddress || !Number.isInteger(prefixLength)) {\n    throw new Error(`not a valid IPv4 subnet: ${subnet}`);\n  }\n\n  if (prefixLength < 0 || prefixLength > 32) {\n    throw new Error(`not a valid IPv4 prefix length: ${prefixLength} (from ${subnet})`);\n  }\n\n  const subnetLong = ipv4ToLong(subnetAddress);\n  return addressLong => {\n    if (prefixLength === 0) {\n      return true;\n    }\n    const subnetPrefix = subnetLong >> (32 - prefixLength);\n    const addressPrefix = addressLong >> (32 - prefixLength);\n\n    return subnetPrefix === addressPrefix;\n  };\n}\n\n// cache these special subnet checkers\nconst specialNetsCache: Record<string, (address: string) => boolean> = {};\n\n/** Test if the given IP address is a private/internal IP address. */\nexport function isPrivate(address: string) {\n  if ('private' in specialNetsCache === false) {\n    specialNetsCache['private'] = createChecker(ipRange.private.ipv4);\n  }\n  return specialNetsCache['private'](address);\n}\n\n/** Test if the given IP address is a localhost address. */\nexport function isLocalhost(address: string) {\n  if ('localhost' in specialNetsCache === false) {\n    specialNetsCache['localhost'] = createChecker(ipRange.localhost.ipv4);\n  }\n  return specialNetsCache['localhost'](address);\n}\n\n/** Test if the given IP address is in a known reserved range and not a normal host IP */\nexport function isReserved(address: string) {\n  if ('reserved' in specialNetsCache === false) {\n    specialNetsCache['reserved'] = createChecker(ipRange.reserved.ipv4);\n  }\n  return specialNetsCache['reserved'](address);\n}\n\n/**\n * Test if the given IP address is a special address of any kind (private, reserved,\n * localhost)\n */\nexport function isSpecial(address: string) {\n  if ('special' in specialNetsCache === false) {\n    specialNetsCache['special'] = createChecker([\n      ...ipRange.private.ipv4,\n      ...ipRange.localhost.ipv4,\n      ...ipRange.reserved.ipv4\n    ]);\n  }\n  return specialNetsCache['special'](address);\n}\n","import * as util from './util';\nimport ipRange from './ipRange';\n\n// Note: Profiling shows that on recent versions of Node, string.split(RegExp) is faster\n// than string.split(string).\nconst dot = /\\./;\nconst mappedIpv4 = /^(.+:ffff:)(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})(?:%.+)?$/;\nconst colon = /:/;\nconst doubleColon = /::/;\n\n/**\n * Given a mapped IPv4 address (e.g. ::ffff:203.0.113.38 or similar), convert it to the\n * equivalent standard IPv6 address.\n * @param ip the IPv4-to-IPv6 mapped address\n */\nfunction mappedIpv4ToIpv6(ip: string) {\n  const matches = ip.match(mappedIpv4);\n\n  if (!matches || !util.isIPv4(matches[2])) {\n    throw new Error(`not a mapped IPv4 address: ${ip}`);\n  }\n\n  // mapped IPv4 address\n  const prefix = matches[1];\n  const ipv4 = matches[2];\n\n  const parts = ipv4.split(dot).map(x => parseInt(x, 10));\n\n  const segment7 = ((parts[0] << 8) + parts[1]).toString(16);\n  const segment8 = ((parts[2] << 8) + parts[3]).toString(16);\n\n  return `${prefix}${segment7}:${segment8}`;\n}\n\n/**\n * Given a mapped IPv4 address, return the bare IPv4 equivalent.\n */\nexport function extractMappedIpv4(ip: string) {\n  const matches = ip.match(mappedIpv4);\n\n  if (!matches || !util.isIPv4(matches[2])) {\n    throw new Error(`not a mapped IPv4 address: ${ip}`);\n  }\n\n  return matches[2];\n}\n\n/**\n * Given an IP address that may have double-colons, expand all segments and return them\n * as an array of 8 segments (16-bit words). As a peformance enhancement (indicated by\n * profiling), for any segment that was missing but should be a '0', returns undefined.\n * @param ip the IPv6 address to expand\n * @throws if the string is not a valid IPv6 address\n */\nfunction getIpv6Segments(ip: string): string[] {\n  if (!util.isIPv6(ip)) {\n    throw new Error(`not a valid IPv6 address: ${ip}`);\n  }\n\n  if (dot.test(ip)) {\n    return getIpv6Segments(mappedIpv4ToIpv6(ip));\n  }\n\n  // break it into an array, including missing \"::\" segments\n  const [beforeChunk, afterChunk] = ip.split(doubleColon);\n\n  const beforeParts = (beforeChunk && beforeChunk.split(colon)) || [];\n  const afterParts = (afterChunk && afterChunk.split(colon)) || [];\n  const missingSegments = new Array<string>(8 - (beforeParts.length + afterParts.length));\n\n  return beforeParts.concat(missingSegments, afterParts);\n}\n\n/**\n * Test if the given IPv6 address is contained in the specified subnet.\n * @param address the IPv6 address to check\n * @param subnet the IPv6 CIDR to test (or an array of them)\n * @throws if the address or subnet are not valid IP addresses, or the CIDR prefix length\n *  is not valid\n */\nexport function isInSubnet(address: string, subnetOrSubnets: string | string[]): boolean {\n  return createChecker(subnetOrSubnets)(address);\n}\n\n/**\n * Create a function to test if a given IPv6 address is contained in the specified subnet.\n * @param subnet the IPv6 CIDR to test (or an array of them)\n * @throws if the subnet(s) are not valid IP addresses, or the CIDR prefix lengths\n *  are not valid\n */\nexport function createChecker(\n  subnetOrSubnets: string | string[]\n): (address: string) => boolean {\n  if (Array.isArray(subnetOrSubnets)) {\n    const checks = subnetOrSubnets.map(subnet => createSegmentChecker(subnet));\n    return address => {\n      const segments = getIpv6Segments(address);\n      return checks.some(check => check(segments));\n    };\n  }\n  const check = createSegmentChecker(subnetOrSubnets);\n  return address => {\n    const segments = getIpv6Segments(address);\n    return check(segments);\n  };\n}\n\n// This creates the last function that works on the most deconstructed data\nfunction createSegmentChecker(subnet: string): (segments: string[]) => boolean {\n  const [subnetAddress, prefixLengthString] = subnet.split('/');\n  const prefixLength = parseInt(prefixLengthString, 10);\n\n  if (!subnetAddress || !Number.isInteger(prefixLength)) {\n    throw new Error(`not a valid IPv6 CIDR subnet: ${subnet}`);\n  }\n\n  if (prefixLength < 0 || prefixLength > 128) {\n    throw new Error(`not a valid IPv6 prefix length: ${prefixLength} (from ${subnet})`);\n  }\n\n  // the next line throws if the address is not a valid IPv6 addresse\n  const subnetSegments = getIpv6Segments(subnetAddress);\n\n  return addressSegments => {\n    for (let i = 0; i < 8; ++i) {\n      const bitCount = Math.min(prefixLength - i * 16, 16);\n\n      if (bitCount <= 0) {\n        break;\n      }\n\n      const subnetPrefix =\n        ((subnetSegments[i] && parseInt(subnetSegments[i], 16)) || 0) >> (16 - bitCount);\n\n      const addressPrefix =\n        ((addressSegments[i] && parseInt(addressSegments[i], 16)) || 0) >>\n        (16 - bitCount);\n\n      if (subnetPrefix !== addressPrefix) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}\n\n// cache these special subnet checkers\nconst specialNetsCache: Record<string, (address: string) => boolean> = {};\n\n/** Test if the given IP address is a private/internal IP address. */\nexport function isPrivate(address: string) {\n  if ('private' in specialNetsCache === false) {\n    specialNetsCache['private'] = createChecker(ipRange.private.ipv6);\n  }\n  return specialNetsCache['private'](address);\n}\n\n/** Test if the given IP address is a localhost address. */\nexport function isLocalhost(address: string) {\n  if ('localhost' in specialNetsCache === false) {\n    specialNetsCache['localhost'] = createChecker(ipRange.localhost.ipv6);\n  }\n  return specialNetsCache['localhost'](address);\n}\n\n/** Test if the given IP address is an IPv4 address mapped onto IPv6 */\nexport function isIPv4MappedAddress(address: string) {\n  if ('mapped' in specialNetsCache === false) {\n    specialNetsCache['mapped'] = createChecker('::ffff:0:0/96');\n  }\n  if (specialNetsCache['mapped'](address)) {\n    const matches = address.match(mappedIpv4);\n    return Boolean(matches && util.isIPv4(matches[2]));\n  }\n  return false;\n}\n\n/** Test if the given IP address is in a known reserved range and not a normal host IP */\nexport function isReserved(address: string) {\n  if ('reserved' in specialNetsCache === false) {\n    specialNetsCache['reserved'] = createChecker(ipRange.reserved.ipv6);\n  }\n  return specialNetsCache['reserved'](address);\n}\n\n/**\n * Test if the given IP address is a special address of any kind (private, reserved,\n * localhost)\n */\nexport function isSpecial(address: string) {\n  if ('special' in specialNetsCache === false) {\n    specialNetsCache['special'] = createChecker([\n      ...ipRange.private.ipv6,\n      ...ipRange.localhost.ipv6,\n      ...ipRange.reserved.ipv6\n    ]);\n  }\n  return specialNetsCache['special'](address);\n}\n","import * as IPv4 from './ipv4';\nimport * as IPv6 from './ipv6';\nimport * as util from './util';\n\nexport { isIP, isIPv4, isIPv6 } from './util';\nexport { IPv4, IPv6 };\n\n/**\n * Test if the given IP address is contained in the specified subnet.\n * @param address the IPv4 or IPv6 address to check\n * @param subnet the IPv4 or IPv6 CIDR to test (or an array of them)\n * @throws if any of the address or subnet(s) are not valid IP addresses, or the CIDR\n *  prefix length is not valid\n */\nexport function isInSubnet(address: string, subnetOrSubnets: string | string[]): boolean {\n  return createChecker(subnetOrSubnets)(address);\n}\n/**\n * Create a function to test if the given IP address is contained in the specified subnet.\n * @param subnet the IPv4 or IPv6 CIDR to test (or an array of them)\n * @throws if any of the subnet(s) are not valid IP addresses, or the CIDR\n *  prefix length is not valid\n */\nexport function createChecker(\n  subnetOrSubnets: string | string[]\n): (address: string) => boolean {\n  if (!Array.isArray(subnetOrSubnets)) {\n    return createChecker([subnetOrSubnets]);\n  }\n\n  const subnetsByVersion = subnetOrSubnets.reduce(\n    (acc, subnet) => {\n      const ip = subnet.split('/')[0];\n      (acc[util.isIP(ip)] as string[]).push(subnet);\n      return acc;\n    },\n    { 0: [], 4: [], 6: [] }\n  );\n\n  if (subnetsByVersion[0].length !== 0) {\n    throw new Error(`some subnets are not valid IP addresses: ${subnetsByVersion[0]}`);\n  }\n\n  const check4 = IPv4.createChecker(subnetsByVersion[4]);\n  const check6 = IPv6.createChecker(subnetsByVersion[6]);\n\n  return address => {\n    if (!util.isIP(address)) {\n      throw new Error(`not a valid IPv4 or IPv6 address: ${address}`);\n    }\n\n    // for mapped IPv4 addresses, compare against both IPv6 and IPv4 subnets\n    if (util.isIPv6(address) && IPv6.isIPv4MappedAddress(address)) {\n      return check6(address) || check4(IPv6.extractMappedIpv4(address));\n    }\n\n    if (util.isIPv6(address)) {\n      return check6(address);\n    } else {\n      return check4(address);\n    }\n  };\n}\n\n/** Test if the given IP address is a private/internal IP address. */\nexport function isPrivate(address: string) {\n  if (util.isIPv6(address)) {\n    if (IPv6.isIPv4MappedAddress(address)) {\n      return IPv4.isPrivate(IPv6.extractMappedIpv4(address));\n    }\n    return IPv6.isPrivate(address);\n  } else {\n    return IPv4.isPrivate(address);\n  }\n}\n\n/** Test if the given IP address is a localhost address. */\nexport function isLocalhost(address: string) {\n  if (util.isIPv6(address)) {\n    if (IPv6.isIPv4MappedAddress(address)) {\n      return IPv4.isLocalhost(IPv6.extractMappedIpv4(address));\n    }\n    return IPv6.isLocalhost(address);\n  } else {\n    return IPv4.isLocalhost(address);\n  }\n}\n\n/** Test if the given IP address is an IPv4 address mapped onto IPv6 */\nexport function isIPv4MappedAddress(address: string) {\n  if (util.isIPv6(address)) {\n    return IPv6.isIPv4MappedAddress(address);\n  } else {\n    return false;\n  }\n}\n\n/** Test if the given IP address is in a known reserved range and not a normal host IP */\nexport function isReserved(address: string) {\n  if (util.isIPv6(address)) {\n    if (IPv6.isIPv4MappedAddress(address)) {\n      return IPv4.isReserved(IPv6.extractMappedIpv4(address));\n    }\n    return IPv6.isReserved(address);\n  } else {\n    return IPv4.isReserved(address);\n  }\n}\n\n/**\n * Test if the given IP address is a special address of any kind (private, reserved,\n * localhost)\n */\nexport function isSpecial(address: string) {\n  if (util.isIPv6(address)) {\n    if (IPv6.isIPv4MappedAddress(address)) {\n      return IPv4.isSpecial(IPv6.extractMappedIpv4(address));\n    }\n    return IPv6.isSpecial(address);\n  } else {\n    return IPv4.isSpecial(address);\n  }\n}\n\nexport const check = isInSubnet;\n"],"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","v4Seg","v4Str","IPv4Reg","RegExp","v6Seg","IPv6Reg","isIPv4","test","isIPv6","isIP","ipv4","ipv6","ipv4ToLong","ip","util.isIPv4","Error","octets","split","parseInt","createChecker","subnetOrSubnets","isArray","checks_1","map","subnet","createLongChecker","address","addressLong","some","check","_a","subnetAddress","prefixLengthString","prefixLength","Number","isInteger","subnetLong","specialNetsCache","isPrivate","ipRange","isLocalhost","isReserved","isSpecial","dot","mappedIpv4","colon","doubleColon","extractMappedIpv4","matches","match","getIpv6Segments","util.isIPv6","prefix","parts","x","toString","mappedIpv4ToIpv6","beforeChunk","afterChunk","beforeParts","afterParts","missingSegments","concat","createSegmentChecker","segments","subnetSegments","addressSegments","bitCount","Math","min","isIPv4MappedAddress","Boolean","isInSubnet","subnetsByVersion","reduce","acc","util.isIP","push","0","4","6","check4","IPv4.createChecker","check6","IPv6.createChecker","IPv6.isIPv4MappedAddress","IPv6.extractMappedIpv4","IPv4.isLocalhost","IPv6.isLocalhost","IPv4.isPrivate","IPv6.isPrivate","IPv4.isReserved","IPv6.isReserved","IPv4.isSpecial","IPv6.isSpecial"],"mappings":"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"}